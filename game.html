<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>3D Maze Game with Custom Character Model and Vendor</title>
        <style>
            body { 
                margin: 0; 
                font-family: Arial, sans-serif; 
                overflow: hidden; 
            }
            canvas { 
                display: block; 
            }
            #info { 
                position: absolute; 
                top: 10px; 
                left: 10px; 
                color: white; 
                background: rgba(0,0,0,0.5); 
                padding: 10px; 
            }
            #vendorMenu, #riddleMenu, #powerUpMenu {
                display: none;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgb(0, 0, 0);
                color: white;
                padding: 20px;
                border-radius: 10px;
            }
            
            button {
                margin: 5px;
                padding: 5px 10px;
                cursor: pointer;
            }
            input {
                margin: 5px;
                padding: 5px;
            }
            #interactionMessage{
                display: none;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%);
                color: white; 
                background: rgba(0, 0, 0, 0.7); 
                padding: 10px; 
                border-radius: 5px;
            }
            #backToMenu { 
                position: absolute;
                top: 10px;
                right: 10px;
                padding: 5px 10px;
                background-color: #8d6e63;
                color: white;
                border: none;
                cursor: pointer;
                z-index: 1000;
            }
            .overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 0, 0, 0.3); /* Semi-transparent red */
                opacity: 0; /* Start as invisible */
                transition: opacity 0.5s; /* Transition effect */
                pointer-events: none; /* Allow clicks to pass through */
                z-index: 9999; /* Ensure it's on top of everything */
            }

            .overlay.pulsate {
                animation: pulse 1s infinite; /* Apply pulsating animation */
            }

            @keyframes pulse {
                0% {
                    opacity: 0.5;
                }
                50% {
                    opacity: 1; /* Fully visible */
                }
                100% {
                    opacity: 0.5;
                }
            }
        </style>
    </head>

    <body>
        <div id="info">
            Health: <span id="health">100</span><br>
            Time: <span id="time">0</span><br>
            <!-- Vendor and Coins -->
            Coins: <span id="coins">0</span><br>
            Press 1 for First Person View, 3 for Third Person View<br>
        </div>
    
        <div id = "interactionMessage">
            Press E to interact with the vendor
        </div>
    
        <div id="vendorMenu">
            <!-- Vendor Menu -->
            <h2>Vendor Interaction</h2>
            <p>You can either answer the riddle for coins or buy power-ups.</p>
            <button onclick="showRiddleMenu()">Answer the Riddle</button>
            <button onclick="showPowerUpMenu()">Buy Power-ups</button>
    
            <button onclick="closeVendorMenu()">Close</button>
        </div>
    
        <div id="riddleMenu">
            <h2>Riddle Challenge</h2>
            <p id="riddleQuestion"></p>
            <input type="text" id="riddleAnswer" placeholder="Your answer">
            <button onclick="submitRiddleAnswer()">Submit Answer</button>
            <button onclick="closeRiddleMenu()">Cancel</button>
        </div>
    
        <div id="powerUpMenu">
            <h2>Buy Power-ups</h2>
            <button onclick="buyPowerUp('superSpeed')">Buy Super Speed (10 coins)</button>
            <button onclick="buyPowerUp('healthBoost')">Buy Health Boost (15 coins)</button>
            <button onclick="buyPowerUp('superJump')">Buy Super Jump(20 coins)</button>
            <button onclick="buyPowerUp('Invincibility')">Buy Invincibility(10 coins)</buton>
            <button onclick="closePowerUpMenu()">Close</button>
        </div>
        <div id="healthOverlay" class="overlay"></div>

        <div id="Name" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); color: white; z-index: 1000;">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0,0,0,0.9); padding: 20px; border-radius: 10px; text-align: center;">
                <h2>Well Done!</h2>
                <p>You completed the maze!</p>
                <label for="playerName">Please enter your name:</label>
                <input type="text" id="playerName" style="margin: 10px 0; padding: 10px; border-radius: 5px; border: none; width: 80%;"/>
                <div>
                    <button id="submitName" style="padding: 10px 15px; background-color: #81c784; border: none; border-radius: 5px; cursor: pointer;">Submit</button>
                </div>
            </div>
        </div>

        <script type="importmap">
            {
                "imports": {
                    "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                    "three/examples/jsm/controls/PointerLockControls.js": "https://unpkg.com/three@0.157.0/examples/jsm/controls/PointerLockControls.js",
                    "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.157.0/examples/jsm/loaders/GLTFLoader.js"
                }
            }
        </script>

        <script>
            // This script tag should be placed before your module script
            function backToMenu() {
                window.location.href = 'index.html';
            }
        </script>

        <button id="backToMenu">Back to Menu</button>
        <script type="module">
            let isPaused = false;
            let isInteracting = false;
            const pauseMenu = document.createElement('div');
            import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
            import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/PointerLockControls.js';
            import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/loaders/GLTFLoader.js';
            import * as CANNON from "https://cdn.jsdelivr.net/npm/cannon-es@0.18.0/dist/cannon-es.js";

            // Constants
            const BOUNDARY_SIZE = 200;  // Updated boundary size
            const CHARACTER_HEIGHT = 2.5;
            const EYE_LEVEL = CHARACTER_HEIGHT * 1.1;
            const FIRST_PERSON_OFFSET = new THREE.Vector3(0, EYE_LEVEL, 0);
            const THIRD_PERSON_OFFSET = new THREE.Vector3(0, 2, -5);  // 2 units above, 5 units behind the character
            const MOVEMENT_SPEED = 5.0;
            const VENDOR_INTERACTION_DISTANCE = 5;
            const gravity = -0.1;  // Gravity strength (negative pulls character down)
            const vendors = [];
            let actions = {};
            let animationFrameId;
            // Variables
            let scene, camera, renderer, controls, ground, character, mixer, vendor;
            let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
            let isFirstPerson = true, isWalking = false, isGrounded = true, topDownViewEnabled = false;
            let invincible = false;
            let health = 100, coins = 0, superSpeedActive = false;

            // Character physics variables
            let jumpVelocity = 0;
            let jumpStrength = 6;
            let jumpFullStrength = 30;
            let characterDirection = new THREE.Vector3(0, 0, 0);
            let cameraOffset = new THREE.Vector3();

            const traps = [];
            const pendulums = [];
            let lastDamageTime = 0;
            const damageCooldown = 1000; // 1 second cooldown between damage applications
            const ANIMATION_DURATION = 110; // Total frames of the animation
            const SPIKES_START_RISING = 30;
            const SPIKES_FULLY_UP = 30;
            const SPIKES_START_LOWERING = 70;
            const SPIKES_FULLY_DOWN = 80;
            
            // Textures
            const mazeOneFloor = new THREE.TextureLoader().load('./assets/mazeOne.png');
            const mazeOneWall = new THREE.TextureLoader().load('./assets/mazeOne.png'); 
            const mazeTwoFloor = new THREE.TextureLoader().load('./assets/mazeTwo.jpg');
            const mazeTwoWall = new THREE.TextureLoader().load('./assets/mazeTwo.jpg'); 
            const mazeThreeFloor = new THREE.TextureLoader().load('./assets/mazeThree.jpg');
            const mazeThreeWall = new THREE.TextureLoader().load('./assets/mazeThree.jpg');


            // Character dimensions and camera offsets
            const characterHeight = 2;
            const eyeLevel = characterHeight * 1.1;
            const firstPersonOffset = new THREE.Vector3(0, eyeLevel, 0);
            const thirdPersonOffset = new THREE.Vector3(0, 2, -5); // 2 units above, 5 units behind the character

            // Timing and movement helpers
            const velocity = new THREE.Vector3();
            const direction = new THREE.Vector3();
            const clock = new THREE.Clock();
            let prevTime = performance.now();
            let startTime, elapsedTime,endTimem,savedTime = 0;
            let timerRunning = false;


            // Gameplay elements
            const coinObjects = [];  // Store coin objects
            let playerBody;  // Placeholder for physics

            // UI Elements
            const healthElement = document.getElementById('health');
            const coinsElement = document.getElementById('coins');
            const vendorMenu = document.getElementById('vendorMenu');
            const powerUpMenu = document.getElementById('powerUpMenu');
            const riddleMenu = document.getElementById('riddleMenu');
            const interactionMessage = document.getElementById('interactionMessage');
            let currentRiddle = null;

            // Set up Cannon.js world
            const world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            
            // Create character in physics world
            const characterRadius = 1; // Adjust radius as needed
            const characterShape = new CANNON.Cylinder(characterRadius, characterRadius, characterHeight, 8);

            const characterBody = new CANNON.Body({
                mass: 5, // Set the mass
                shape: characterShape,
                position: new CANNON.Vec3(20, characterHeight/2, 3) // Starting position
            });
            characterBody.angularFactor.set(0, 1, 0);  // Only allow rotation along the Y axis

            world.addBody(characterBody);

            const mazeOne = [
                { type: 'line', x1: 1.0, y1: 1.0, x2: 17.0, y2: 1.0 },
                { type: 'line', x1: 25.0, y1: 1.0, x2: 49.0, y2: 1.0 },
                { type: 'line', x1: 1.0, y1: 9.0, x2: 9.0, y2: 9.0 },
                { type: 'line', x1: 17.0, y1: 9.0, x2: 25.0, y2: 9.0 },
                { type: 'line', x1: 33.0, y1: 9.0, x2: 49.0, y2: 9.0 },
                { type: 'line', x1: 25.0, y1: 17.0, x2: 41.0, y2: 17.0 },
                { type: 'line', x1: 1.0, y1: 25.0, x2: 9.0, y2: 25.0 },
                { type: 'line', x1: 9.0, y1: 33.0, x2: 17.0, y2: 33.0 },
                { type: 'line', x1: 41.0, y1: 33.0, x2: 49.0, y2: 33.0 },
                { type: 'line', x1: 9.0, y1: 41.0, x2: 25.0, y2: 41.0 },
                { type: 'line', x1: 33.0, y1: 41.0, x2: 41.0, y2: 41.0 },
                { type: 'line', x1: 1.0, y1: 49.0, x2: 25.0, y2: 49.0 },
                { type: 'line', x1: 33.0, y1: 49.0, x2: 49.0, y2: 49.0 },
                { type: 'line', x1: 1.0, y1: 1.0, x2: 1.0, y2: 49.0 },
                { type: 'line', x1: 9.0, y1: 17.0, x2: 9.0, y2: 25.0 },
                { type: 'line', x1: 17.0, y1: 9.0, x2: 17.0, y2: 33.0 },
                { type: 'line', x1: 25.0, y1: 1.0, x2: 25.0, y2: 9.0 },
                { type: 'line', x1: 25.0, y1: 17.0, x2: 25.0, y2: 49.0 },
                { type: 'line', x1: 33.0, y1: 25.0, x2: 33.0, y2: 49.0 },
                { type: 'line', x1: 41.0, y1: 25.0, x2: 41.0, y2: 33.0 },
                { type: 'line', x1: 49.0, y1: 1.0, x2: 49.0, y2: 49.0 }
            ];



            const mazeTwo = [
                { type: 'line', x1: 1.0, y1: 1.0, x2: 25.0, y2: 1.0 },
                { type: 'line', x1: 33.0, y1: 1.0, x2: 65.0, y2: 1.0 },
                { type: 'line', x1: 25.0, y1: 9.0, x2: 33.0, y2: 9.0 },
                { type: 'line', x1: 41.0, y1: 9.0, x2: 57.0, y2: 9.0 },
                { type: 'line', x1: 17.0, y1: 17.0, x2: 25.0, y2: 17.0 },
                { type: 'line', x1: 41.0, y1: 17.0, x2: 65.0, y2: 17.0 },
                { type: 'line', x1: 1.0, y1: 25.0, x2: 17.0, y2: 25.0 },
                { type: 'line', x1: 9.0, y1: 33.0, x2: 33.0, y2: 33.0 },
                { type: 'line', x1: 49.0, y1: 33.0, x2: 57.0, y2: 33.0 },
                { type: 'line', x1: 17.0, y1: 41.0, x2: 57.0, y2: 41.0 },
                { type: 'line', x1: 1.0, y1: 49.0, x2: 9.0, y2: 49.0 },
                { type: 'line', x1: 25.0, y1: 49.0, x2: 33.0, y2: 49.0 },
                { type: 'line', x1: 41.0, y1: 49.0, x2: 49.0, y2: 49.0 },
                { type: 'line', x1: 57.0, y1: 49.0, x2: 65.0, y2: 49.0 },
                { type: 'line', x1: 9.0, y1: 57.0, x2: 17.0, y2: 57.0 },
                { type: 'line', x1: 25.0, y1: 57.0, x2: 41.0, y2: 57.0 },
                { type: 'line', x1: 1.0, y1: 65.0, x2: 33.0, y2: 65.0 },
                { type: 'line', x1: 41.0, y1: 65.0, x2: 65.0, y2: 65.0 },
                { type: 'line', x1: 1.0, y1: 1.0, x2: 1.0, y2: 65.0 },
                { type: 'line', x1: 9.0, y1: 9.0, x2: 9.0, y2: 25.0 },
                { type: 'line', x1: 9.0, y1: 33.0, x2: 9.0, y2: 41.0 },
                { type: 'line', x1: 17.0, y1: 1.0, x2: 17.0, y2: 17.0 },
                { type: 'line', x1: 17.0, y1: 41.0, x2: 17.0, y2: 65.0 },
                { type: 'line', x1: 25.0, y1: 17.0, x2: 25.0, y2: 33.0 },
                { type: 'line', x1: 25.0, y1: 49.0, x2: 25.0, y2: 57.0 },
                { type: 'line', x1: 33.0, y1: 1.0, x2: 33.0, y2: 25.0 },
                { type: 'line', x1: 41.0, y1: 9.0, x2: 41.0, y2: 17.0 },
                { type: 'line', x1: 41.0, y1: 25.0, x2: 41.0, y2: 41.0 },
                { type: 'line', x1: 41.0, y1: 49.0, x2: 41.0, y2: 65.0 },
                { type: 'line', x1: 49.0, y1: 17.0, x2: 49.0, y2: 25.0 },
                { type: 'line', x1: 49.0, y1: 57.0, x2: 49.0, y2: 65.0 },
                { type: 'line', x1: 57.0, y1: 25.0, x2: 57.0, y2: 41.0 },
                { type: 'line', x1: 57.0, y1: 49.0, x2: 57.0, y2: 57.0 },
                { type: 'line', x1: 65.0, y1: 1.0, x2: 65.0, y2: 65.0 }
            ];



            const mazeThree = [
            { type: 'line', x1: 1.0, y1: 1.0, x2: 41.0, y2: 1.0 },
            { type: 'line', x1: 49.0, y1: 1.0, x2: 89.0, y2: 1.0 },
            { type: 'line', x1: 9.0, y1: 9.0, x2: 25.0, y2: 9.0 },
            { type: 'line', x1: 33.0, y1: 9.0, x2: 41.0, y2: 9.0 },
            { type: 'line', x1: 57.0, y1: 9.0, x2: 65.0, y2: 9.0 },
            { type: 'line', x1: 73.0, y1: 9.0, x2: 81.0, y2: 9.0 },
            { type: 'line', x1: 9.0, y1: 17.0, x2: 57.0, y2: 17.0 },
            { type: 'line', x1: 65.0, y1: 17.0, x2: 73.0, y2: 17.0 },
            { type: 'line', x1: 49.0, y1: 25.0, x2: 57.0, y2: 25.0 },
            { type: 'line', x1: 73.0, y1: 25.0, x2: 81.0, y2: 25.0 },
            { type: 'line', x1: 1.0, y1: 33.0, x2: 17.0, y2: 33.0 },
            { type: 'line', x1: 33.0, y1: 33.0, x2: 65.0, y2: 33.0 },
            { type: 'line', x1: 73.0, y1: 33.0, x2: 89.0, y2: 33.0 },
            { type: 'line', x1: 9.0, y1: 41.0, x2: 17.0, y2: 41.0 },
            { type: 'line', x1: 25.0, y1: 41.0, x2: 33.0, y2: 41.0 },
            { type: 'line', x1: 41.0, y1: 41.0, x2: 81.0, y2: 41.0 },
            { type: 'line', x1: 25.0, y1: 49.0, x2: 41.0, y2: 49.0 },
            { type: 'line', x1: 49.0, y1: 49.0, x2: 65.0, y2: 49.0 },
            { type: 'line', x1: 73.0, y1: 49.0, x2: 81.0, y2: 49.0 },
            { type: 'line', x1: 57.0, y1: 57.0, x2: 73.0, y2: 57.0 },
            { type: 'line', x1: 81.0, y1: 57.0, x2: 89.0, y2: 57.0 },
            { type: 'line', x1: 1.0, y1: 65.0, x2: 17.0, y2: 65.0 },
            { type: 'line', x1: 33.0, y1: 65.0, x2: 57.0, y2: 65.0 },
            { type: 'line', x1: 73.0, y1: 65.0, x2: 81.0, y2: 65.0 },
            { type: 'line', x1: 9.0, y1: 73.0, x2: 25.0, y2: 73.0 },
            { type: 'line', x1: 57.0, y1: 73.0, x2: 65.0, y2: 73.0 },
            { type: 'line', x1: 33.0, y1: 81.0, x2: 73.0, y2: 81.0 },
            { type: 'line', x1: 1.0, y1: 89.0, x2: 41.0, y2: 89.0 },
            { type: 'line', x1: 49.0, y1: 89.0, x2: 89.0, y2: 89.0 },
            { type: 'line', x1: 1.0, y1: 1.0, x2: 1.0, y2: 89.0 },
            { type: 'line', x1: 9.0, y1: 9.0, x2: 9.0, y2: 25.0 },
            { type: 'line', x1: 9.0, y1: 41.0, x2: 9.0, y2: 57.0 },
            { type: 'line', x1: 9.0, y1: 81.0, x2: 9.0, y2: 89.0 },
            { type: 'line', x1: 17.0, y1: 25.0, x2: 17.0, y2: 41.0 },
            { type: 'line', x1: 17.0, y1: 49.0, x2: 17.0, y2: 65.0 },
            { type: 'line', x1: 17.0, y1: 73.0, x2: 17.0, y2: 81.0 },
            { type: 'line', x1: 25.0, y1: 17.0, x2: 25.0, y2: 41.0 },
            { type: 'line', x1: 25.0, y1: 49.0, x2: 25.0, y2: 89.0 },
            { type: 'line', x1: 33.0, y1: 9.0, x2: 33.0, y2: 17.0 },
            { type: 'line', x1: 33.0, y1: 25.0, x2: 33.0, y2: 41.0 },
            { type: 'line', x1: 33.0, y1: 57.0, x2: 33.0, y2: 81.0 },
            { type: 'line', x1: 41.0, y1: 25.0, x2: 41.0, y2: 33.0 },
            { type: 'line', x1: 41.0, y1: 41.0, x2: 41.0, y2: 57.0 },
            { type: 'line', x1: 41.0, y1: 73.0, x2: 41.0, y2: 81.0 },
            { type: 'line', x1: 49.0, y1: 1.0, x2: 49.0, y2: 17.0 },
            { type: 'line', x1: 49.0, y1: 49.0, x2: 49.0, y2: 73.0 },
            { type: 'line', x1: 49.0, y1: 81.0, x2: 49.0, y2: 89.0 },
            { type: 'line', x1: 57.0, y1: 17.0, x2: 57.0, y2: 25.0 },
            { type: 'line', x1: 65.0, y1: 9.0, x2: 65.0, y2: 33.0 },
            { type: 'line', x1: 65.0, y1: 57.0, x2: 65.0, y2: 73.0 },
            { type: 'line', x1: 73.0, y1: 1.0, x2: 73.0, y2: 9.0 },
            { type: 'line', x1: 73.0, y1: 41.0, x2: 73.0, y2: 57.0 },
            { type: 'line', x1: 73.0, y1: 65.0, x2: 73.0, y2: 81.0 },
            { type: 'line', x1: 81.0, y1: 9.0, x2: 81.0, y2: 25.0 },
            { type: 'line', x1: 81.0, y1: 73.0, x2: 81.0, y2: 89.0 },
            { type: 'line', x1: 89.0, y1: 1.0, x2: 89.0, y2: 89.0 }
        ];



const mockRiddles = [
            {
                question: "I come to those who search for me, though I am something you cannot see. I’m the end of a journey and the start of a dream. What am I?",
                answer: "goal"
            },
            {
                question: "Many paths I offer, but one leads to the prize. Through twists, turns, and careful tries, only then will you reach the end. What am I?",
                answer: "maze"
            },
            {
                question: "I can open any way, though I have no form to stay. I’m a friend to those who seek, finding me is what they seek. What am I?",
                answer: "key"
            },
            {
                question: "I am a guide, though I do not speak. I help those lost, and that is my peak. With my light, you’ll find the night turns bright. What am I?",
                answer: "torch"
            },
            {
                question: "The more you take, the more you leave behind. What am I?",
                answer: "footsteps"
            }
        ];
        function startTimer() {
            startTime = Date.now();  // Save the start time
            timerRunning = true;     // Mark timer as running
        }

        // Stop timer function (optional if you want to stop at maze completion)
        function stopTimer() {
            endTime = Date.now();
            savedTime = Math.floor((endTime - startTime) / 1000);
            timerRunning = false;
        }

        function setupScene() {
            scene = new THREE.Scene();
    
            // Set up the camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    
            // Set up the renderer with shadow map and tone mapping
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Use ACES filmic tone mapping
            renderer.toneMappingExposure = 1; // Adjust tone mapping exposure

    
            // Append renderer to the DOM
            document.body.appendChild(renderer.domElement);
    
            // Position the camera near the vendor
            camera.position.set(0, 2, 5); 
            
            // Set up the audio listener and load the background music
            const listener = new THREE.AudioListener();
            camera.add(listener);

            // Load background music
            const sound = new THREE.Audio(listener);
            const audioLoader = new THREE.AudioLoader();

        // Load the audio file but don't play it yet
            audioLoader.load('background.mp3', function(buffer) {
            sound.setBuffer(buffer);
            sound.setLoop(true);  // Set to loop
            sound.setVolume(0.5); // Set volume
            console.log("Audio loaded, waiting for user interaction to start playing.");
            
            // Add a click event listener to play the sound on user interaction
            document.body.addEventListener('click', function() {
                // Resume the AudioContext if needed
                if (THREE.AudioContext.getContext().state === 'suspended') {
                    THREE.AudioContext.getContext().resume().then(() => {
                        console.log("AudioContext resumed and music started.");
                        sound.play(); // Play the music after user interaction
                    });
                } else {
                    sound.play();  // If already resumed, just play the music
                }
            }, { once: true });  // Ensure the music only starts once
        },
        function(xhr) {
            console.log((xhr.loaded / xhr.total * 100) + '% music loaded');
        },
        function(error) {
            console.error('An error occurred while loading the audio file:', error);
        });
        }
        
let spotlight;
        function setupLighting() {
            // Set up ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.05); // Lower intensity ambient light
            scene.add(ambientLight);

        if (mazeLevel!=mazeOne){


            //flashlight as a spotlight attached to the camera
            spotlight = new THREE.SpotLight(0xffffff, 3, 100, Math.PI / 8, 0.3, 1);
            spotlight.position.copy(camera.position); 
            spotlight.castShadow = true; // Enable shadows

            spotlight.shadow.mapSize.width = 2048; // Shadow map resolution
            spotlight.shadow.mapSize.height = 2048;

            spotlight.shadow.camera.near = 0.5;
            spotlight.shadow.camera.far = 50;
            spotlight.shadow.camera.fov = 5;  // Field of view of the shadow camera

            spotlight.shadow.bias = -0.0001;


            const target = new THREE.Object3D();
            target.position.set(0, 0, -1);  // In front of the camera
            spotlight.target.position.copy(target.position.add(camera.position)); 
            scene.add(spotlight.target);
            scene.add(spotlight);  // Add spotlight to the scene
        }
            
        }
        function createGround(X_Max,Z_Max) {
            const groundGeometry = new THREE.PlaneGeometry(X_Max, Z_Max);
            let groundMaterial;
            if (mazeLevel == mazeOne){
                groundMaterial = new THREE.MeshStandardMaterial({ map: mazeOneFloor  });
            } else if (mazeLevel == mazeTwo){
                groundMaterial = new THREE.MeshStandardMaterial({ map: mazeTwoFloor  });
            } else {
                groundMaterial = new THREE.MeshStandardMaterial({color: 0x808080});
            }
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow=true;
            scene.add(ground);

            ground.position.set(X_Max / 2, 0, Z_Max / 2);
            scene.add(ground);
            // Create ground in Cannon.js
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
            groundBody.position.set(X_Max / 2, 0, Z_Max / 2);
            world.addBody(groundBody);

        }
        function createPendulum() {
            // Reduced ball size (from 1 to 0.5)
            const rodGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 32);
            const ballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            
            const rodMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2c2c2c,
                metalness: 0.7,
                roughness: 0.3
            });
            const ballMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a,
                metalness: 0.8,
                roughness: 0.2
            });

            const rod = new THREE.Mesh(rodGeometry, rodMaterial);
            rod.position.y = -2; // Center the rod at the pivot point

            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.y = -3.5; // Position at the bottom of the rod

            const pendulum = new THREE.Group();
            pendulum.add(rod);

            const spikeGeometry = new THREE.ConeGeometry(0.1, 0.25, 8); // Reduced spike size to match smaller ball
            const spikeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x303030,
                shininess: 80,
                specular: 0x444444 
            });
            const numSpikes = 50;
            
            for (let i = 0; i < numSpikes; i++) {
                const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                
                // Calculate point on sphere using fibonacci distribution
                const y = 1 - (i / (numSpikes - 1)) * 2;
                const radius = Math.sqrt(1 - y * y);
                const theta = ((Math.PI * (3 - Math.sqrt(5))) * i) % (2 * Math.PI);
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;
                
                // Position spike (reduced multiplier from 1.2 to 0.6 to match smaller ball)
                spike.position.set(x * 0.6, y * 0.6, z * 0.6);
                
                // Calculate normal vector (direction from center to point on sphere)
                const normal = new THREE.Vector3(x, y, z).normalize();
                
                // Create orientation matrix
                const matrix = new THREE.Matrix4();
                const up = new THREE.Vector3(0, 1, 0);
                const axis = new THREE.Vector3();
                axis.crossVectors(up, normal).normalize();
                const angle = Math.acos(up.dot(normal));
                matrix.makeRotationAxis(axis, angle);
                
                // Apply orientation
                spike.quaternion.setFromRotationMatrix(matrix);
                
                ball.add(spike);
            }

            pendulum.add(ball);
            scene.add(pendulum);

            return {
                model: pendulum,
                ball: ball
            };
        }

        function animatePendulum(pendulum) {
            const time = Date.now() * 0.002;
            const maxAngle = Math.PI / 4;
            pendulum.rotation.z = maxAngle * Math.sin(time);
        }


        function createTraps(mazeNumber) {
            let trapPositions;

            if (mazeNumber === mazeOne) {
                trapPositions = [
                    { x: 14, z: 10 },
                    { x: 16, z: 10 }, 
                    { x: 12, z: 10 },
                    { x: 10, z: 10 }, 
                    { x: 12, z: 12 },
                    { x: 14, z: 12 },
                    { x: 16, z: 12 },
                    { x: 10, z: 12 }, // Positions for Maze One
                    
                    { x: 25, z: 16 },
                    { x: 25, z: 14 },
                    { x: 25, z: 12 },
                    { x: 25, z: 10 },

                    { x: 27, z: 16 },
                    { x: 27, z: 14 },
                    { x: 27, z: 12 },
                    { x: 27, z: 10 },
                     
                    
                    { x: 35, z: 18 },
                    { x: 35, z: 20 },
                    { x: 35, z: 22 },
                    { x: 35, z: 24 },
                    
                    { x: 33, z: 18 },
                    { x: 33, z: 20 },
                    { x: 33, z: 22 },
                    { x: 33, z: 24 },
                ];
            } else if (mazeNumber === mazeTwo) {
                trapPositions = [
                    {x: 35, z: 26},
                    {x: 35, z: 28},
                    {x: 35, z: 30},
                    {x: 35, z: 32},
                    {x: 33, z: 26},
                    {x: 33, z: 28},
                    {x: 33, z: 30},
                    {x: 33, z: 32},
                     
                    {x:15, z:58},
                    {x:15, z:60},
                    {x:15, z:62},
                    {x:15, z:64},
                    {x:13, z:58},
                    {x:13, z:60},
                    {x:13, z:62},
                    {x:13, z:64},
                      
                    {x:2, z:15},
                    {x:4, z:15},
                    {x:6, z:15},
                    {x:8, z:15},                     
                    {x:2, z:13},
                    {x:4, z:13},
                    {x:6, z:13},
                    {x:8, z:13},
                    
                    {x:43, z:10},
                    {x:43, z:12},
                    {x:43, z:14}, 
                    {x:43, z:16},
                    {x:45, z:10},
                    {x:45, z:12},
                    {x:45, z:14}, 
                    {x:45, z:16},

                    {x: 60, z: 59},
                    {x: 60, z: 61},
                    {x: 60, z: 63},
                    {x: 60, z: 65},
                    {x: 62, z: 59},
                    {x: 62, z: 61},
                    {x: 62, z: 63},
                    {x: 62, z: 65}
                
                ];
            } else {
                trapPositions = [
                    { x: 12, z: 10 },
                    { x: 12, z: 12 },
                    { x: 12, z: 14 },
                    { x: 12, z: 16},
                    { x: 14, z: 10 },
                    { x: 14, z: 12 },
                    { x: 14, z: 14 },
                    { x: 14, z: 16},

                    {x: 10, z: 50 },
                    {x: 12, z: 50 },
                    {x: 14, z: 50 },
                    {x: 16, z: 50 },
                    {x: 10, z: 52 },
                    {x: 12, z: 52 },
                    {x: 14, z: 52 },
                    {x: 16, z: 52 },

                    {x: 17, z: 82 },
                    {x: 17, z: 84 },
                    {x: 17, z: 86 },
                    {x: 17, z: 88 },
                    {x: 15, z: 82 },
                    {x: 15, z: 84 },
                    {x: 15, z: 86 },
                    {x: 15, z: 88 },
                    
                    {x: 49, z: 26 },
                    {x: 49, z: 28 },
                    {x: 49, z: 30 },
                    {x: 49, z: 32 },
                    {x: 47, z: 26 },
                    {x: 47, z: 28 },
                    {x: 47, z: 30 },
                    {x: 47, z: 32 },
                    
                    {x: 49, z: 34 },
                    {x: 49, z: 36 },
                    {x: 49, z: 38 },
                    {x: 49, z: 40 },
                    {x: 47, z: 34 },
                    {x: 47, z: 36 },
                    {x: 47, z: 38 },
                    {x: 47, z: 40 },
                    
                    {x: 66, z: 50 },
                    {x: 68, z: 50 },
                    {x: 70, z: 50 },
                    {x: 72, z: 50 },                  
                    {x: 66, z: 48 },
                    {x: 68, z: 48 },
                    {x: 70, z: 48 },
                    {x: 72, z: 48 },
                    
                ];
            }

            // Clear any existing traps before adding new ones for the current maze
            traps.forEach(trap => {
                scene.remove(trap.model);
            });
            traps.length = 0;

            // Load traps for the specified maze
            trapPositions.forEach(position => {
                const loader = new GLTFLoader();
                loader.load(
                    'trap.glb',
                    function (gltf) {
                        const trapModel = gltf.scene;
                        trapModel.position.set(position.x, 0.2, position.z);
                        trapModel.scale.set(0.2, 0.2, 0.2);

                        if (gltf.animations && gltf.animations.length) {
                            const trapMixer = new THREE.AnimationMixer(trapModel);
                            const spikeAction = trapMixer.clipAction(gltf.animations[0]);
                            spikeAction.setLoop(THREE.LoopRepeat);
                            spikeAction.play();

                            traps.push({
                                model: trapModel,
                                mixer: trapMixer,
                                spikeAction: spikeAction,
                                isSpikesUp: false,
                                previousState: false,
                                animationTime: 0
                            });
                        }

                        scene.add(trapModel);
                    },
                    function (xhr) {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                    function (error) {
                        console.error('An error occurred while loading the trap', error);
                    }
                );
            });
        }
        function createPendulums(mazeNumber) {
            let pendulumPositions;

            if (mazeNumber === mazeOne) {
                pendulumPositions = [
                    { x: 13, z: 11, swingAxis: 'z' },
                    { x: 26, z: 13, swingAxis: 'x' },
                    { x: 34, z: 21, swingAxis: 'x' }
                ];
            } else if (mazeNumber === mazeTwo) {
                pendulumPositions = [
                    { x: 34, z: 29, swingAxis: 'x' },
                    { x: 14, z: 61, swingAxis: 'x' },
                    { x: 5, z: 14, swingAxis: 'z' },
                    { x: 44, z: 13, swingAxis: 'x' },
                    { x: 60, z: 61, swingAxis: 'x' }                
                ];
            } else {
                pendulumPositions = [
                    { x: 13, z: 13, swingAxis: 'x' },
                    { x: 13, z: 51, swingAxis: 'z' },
                    { x: 16, z: 85, swingAxis: 'x' },
                    { x: 48, z: 29, swingAxis: 'x' },
                    { x: 48, z: 37, swingAxis: 'x' },
                    { x: 69, z: 49, swingAxis: 'z' }                    
                ];
            }

            pendulums.forEach(pendulum => {
                scene.remove(pendulum.model);
            });
            pendulums.length = 0;

            pendulumPositions.forEach(position => {
                const { model: pendulum, ball } = createPendulum();
                pendulum.position.set(position.x, 6, position.z);
                
                pendulums.push({
                    model: pendulum,
                    ball: ball,
                    swingAxis: position.swingAxis,
                    angle: 0,
                    speed: 0.03,
                    maxAngle: Math.PI / 4
                });
            });
        }

        function checkPendulumCollisions() {
            const now = Date.now();
            pendulums.forEach(pendulum => {
                pendulum.model.updateMatrixWorld();
                const ballWorldPosition = new THREE.Vector3();
                pendulum.ball.getWorldPosition(ballWorldPosition);

                // Get the character's position
                const characterPosition = character.position;

                const distanceXZ = Math.sqrt(
                    Math.pow(characterPosition.x - ballWorldPosition.x, 2) +
                    Math.pow(characterPosition.z - ballWorldPosition.z, 2)
                );

                const collisionThreshold = characterRadius + 0.5;

                if (distanceXZ < collisionThreshold && now - lastDamageTime > damageCooldown) {
                    console.log("Collision with pendulum!");
                    applyDamage(10);
                    lastDamageTime = now;
                }
            });
        }


        characterBody.addEventListener("collide", function(e) {
            // Collision detected, you can handle the collision here
            console.log("Collision with", e.body);  // e.body is the object the character collided with
        });


        function loadCharacterModel() {
            const loader = new GLTFLoader();
            loader.load(
                'player2.glb',
                function (gltf) {
                    character = gltf.scene;
                    character.traverse((node) => {
                        if (node.isMesh) {
                            node.castShadow = true;
                        }
                    });
                    character.position.copy(characterBody.position);
                    scene.add(character);
                    characterBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), Math.PI); 
                    character.scale.set(1, 1, 1);
                    character.castShadow = true;


                    setupControls();
                    animate(); // Start animation loop
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('An error happened', error);
                }
            );
        }

        function setupControls() {
            controls = new PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            document.addEventListener('click', (event) => {
                const vendorMenu = document.getElementById('vendorMenu'); 
                const isMenuClick = vendorMenu && vendorMenu.contains(event.target);

                if (!isMenuClick && !isInteracting) {
                    controls.lock();
                    console.log("Pointer locked"); 
                }
            });
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            updateCameraPosition();
        }

        function updateCharacterMovement(delta) {
            const moveSpeed = superSpeedActive ? MOVEMENT_SPEED * 2 : MOVEMENT_SPEED;
            const velocity = new CANNON.Vec3();

            let forward = 0, right = 0;
            if (moveForward) forward += 1;
            if (moveBackward) forward -= 1;
            if (moveLeft) right -= 1;
            if (moveRight) right += 1;

            // Get character's forward and right direction
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0;
            cameraDirection.normalize();
            const sideways = new THREE.Vector3(-cameraDirection.z, 0, cameraDirection.x);

            // Apply velocity based on the movement directions
            velocity.x = (forward * cameraDirection.x + right * sideways.x) * moveSpeed;
            velocity.z = (forward * cameraDirection.z + right * sideways.z) * moveSpeed;

            // Update the physics engine
            characterBody.velocity.x = velocity.x;
            characterBody.velocity.z = velocity.z;

            // Rotate character to face movement direction
            if (velocity.x !== 0 || velocity.z !== 0) {
                const angle = Math.atan2(velocity.x, velocity.z);
                characterBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle);
            }
        }




        function onKeyDown(event) {
            if (event.code === 'ShiftLeft') {
            togglePause();
            return;
            }

            if (isPaused) return; 
            switch (event.code) {
                case 'KeyW': 
                    moveForward = true; 
                    playWalkAnimation();  // Start walk animation
                    break;
                case 'KeyS': 
                    moveBackward = true;
                    playWalkAnimation(); 
                    break;
                case 'KeyA': 
                    moveLeft = true; 
                    playWalkAnimation();
                    break;
                case 'KeyD': 
                    moveRight = true; 
                    playWalkAnimation();
                    break;
                case 'Space': 
                    jump();  // Handle jump on Space key
                    break;
                case 'Digit1': 
                    setFirstPersonView();  // Switch to First Person View
                    break;
                case 'Digit3': 
                    setThirdPersonView();  // Switch to Third Person View
                    break;
                case 'Digit5': 
                    toggleTopDownView();  // Toggle Top-Down view
                    break;
                case 'KeyE': 
                    tryInteractWithVendor();  // Interact with vendor
                    break;
                default:
                    console.log(`Unhandled key: ${event.code}`);  // For debugging unhandled keys
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': 
                    moveForward = false; 
                    break;
                case 'KeyS': 
                    moveBackward = false; 
                    break;
                case 'KeyA': 
                    moveLeft = false; 
                    break;
                case 'KeyD': 
                    moveRight = false; 
                    break;
            }

            // Stop animation if no movement keys are pressed
            if (!moveForward && !moveBackward && !moveLeft && !moveRight) {
                stopWalkAnimation();
            }
        }

        function setTopDownView() {
            // Position the camera above the maze, assuming maze boundaries fit within (0, 0) to (boundarySize, boundarySize)
            const mazeCenterX = 65;  // Adjust as per the center of your maze (based on coordinates)
            const mazeCenterZ = 65;  // Same for Z axis (if the maze lies on the XZ plane)

            // Position the camera above the maze
            camera.position.set(mazeCenterX, 160, mazeCenterZ);  // 200 units high above the maze

            // Make the camera point straight down
            camera.rotation.set(-Math.PI / 2, 0, 0);  // Rotate camera to look downward

            // Ensure the camera updates its matrix
            camera.updateProjectionMatrix();
        }

        function toggleTopDownView() {
            topDownViewEnabled = !topDownViewEnabled;  // Toggle the flag

            if (topDownViewEnabled) {
                setTopDownView();  // Set the camera for top-down view
            } else {
                // Return the camera to the character's view (you may need to define what this means)
                updateCameraPosition();  // Update the camera to the character's position
            }
        }

        function setFirstPersonView() {
            isFirstPerson = true;
            updateCameraPosition();
        }

        function setThirdPersonView() {
            isFirstPerson = false;
            updateCameraPosition();
        }

        function updateCameraPosition() {
    if (topDownViewEnabled) return;

    if (!character) return;

    const characterPosition = new THREE.Vector3().copy(characterBody.position);

    if (isFirstPerson) {
        // First Person View
        camera.position.copy(characterPosition).add(firstPersonOffset);
        controls.getObject().position.copy(camera.position);
    } else {
        // Third Person View
        const idealOffset = new THREE.Vector3().copy(thirdPersonOffset);
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        cameraDirection.y = 0;
        cameraDirection.normalize();

        idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.atan2(cameraDirection.x, cameraDirection.z));
        camera.position.copy(characterPosition).add(idealOffset);
        camera.lookAt(characterPosition.clone().add(new THREE.Vector3(0, characterHeight, 0)));
    }
}
        function addExitLight(goalX, goalZ) {
            // Create the exit light (a spotlight)
            const exitLight = new THREE.SpotLight(0xffd700, 2, 50, Math.PI / 6, 0.3, 1);  // Golden yellow light
            exitLight.position.set(goalX, 10, goalZ);  // Position it above the goal

            // Enable shadows for the exit light
            exitLight.castShadow = true;
            exitLight.shadow.mapSize.width = 1024;  // Adjust for higher resolution shadows
            exitLight.shadow.mapSize.height = 1024;
            exitLight.shadow.camera.near = 1;
            exitLight.shadow.camera.far = 50;

            // Create a target object for the exit light to point downward
            const exitTarget = new THREE.Object3D();
            exitTarget.position.set(goalX, 0, goalZ);  // Aim the light at the goal
            scene.add(exitTarget);
            exitLight.target = exitTarget;  // Set the light's target

            // Add the exit light and target to the scene
            scene.add(exitLight);
            scene.add(exitLight.target);
        }

        function playWalkAnimation() {
            if (!isWalking && mixer) {
                const walkAction = mixer.clipAction('Walk'); // Replace 'Walk' with your animation name
                walkAction.play();
                isWalking = true; // Set walking state to true
            }
        }

        function stopWalkAnimation() {
            if (isWalking && mixer) {
                const walkAction = mixer.clipAction('Walk'); // Replace 'Walk' with your animation name
                walkAction.stop();
                isWalking = false; // Set walking state to false
            }
        }
        function checkTrapCollisions() {
            if (!character) return;

            const now = Date.now();
            traps.forEach(trap => {
                const distance = character.position.distanceTo(trap.model.position);
                if (distance < 1.5 && trap.isSpikesUp && now - lastDamageTime > damageCooldown) {
                    console.log("Damage applied! Spikes are up.");
                    applyDamage(10);
                    lastDamageTime = now;
                }
            });
        }

        let mixers = []; // Array to hold all animation mixers

        let lastTime = performance.now();
function animate() {
    animationFrameId = requestAnimationFrame(animate);
    if (isPaused) return;
    const delta = clock.getDelta();
    world.step(1 / 60);  // Update the physics at 60fps

    // Update the animation mixer if it exists
    if (mixer) {
        mixer.update(delta);
    }

    // Update trap animations
    traps.forEach(trap => {
        trap.mixer.update(delta);
        trap.animationTime = (trap.animationTime + delta) % (ANIMATION_DURATION / 24);
        const frame = Math.floor(trap.animationTime * 30);
        trap.isSpikesUp = frame >= SPIKES_FULLY_UP && frame < SPIKES_START_LOWERING;
        if (trap.isSpikesUp !== trap.previousState) {
            console.log(`Frame: ${frame}, Spikes Up: ${trap.isSpikesUp}`);
            trap.previousState = trap.isSpikesUp;
        }
    });
    
    function updatePendulums(deltaTime) {
                pendulums.forEach(pendulum => {
                    pendulum.angle += pendulum.speed;
                    if (Math.abs(pendulum.angle) >= pendulum.maxAngle) {
                        pendulum.speed *= -1; // Reverse direction at max angle
                    }
                    
                    if (pendulum.swingAxis === 'x') {
                        pendulum.model.rotation.x = pendulum.angle;
                    } else {
                        pendulum.model.rotation.z = pendulum.angle;
                    }
                });
            }

            updatePendulums(delta);

            // Sync the Three.js character position with the Cannon.js physics body
        if (controls && controls.isLocked) {
        updateCharacterMovement(delta);

        // Sync the Three.js character position with the Cannon.js physics body
        if (character && characterBody) {
            character.position.copy(characterBody.position);
            character.quaternion.copy(characterBody.quaternion);
        }
        applyOverlay();
        checkTrapCollisions();
        checkPendulumCollisions();
        checkForCoins();
        checkGameStatus(mazeLevel);
        applyGravity();
    } else {
        console.log("Controls are not locked");
    }
    //flashlight//
    // Update the spotlight to point in the direction the camera is looking
    if (spotlight){
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection); // Get the camera's direction
        cameraDirection.normalize();//Normalize to ensure correct length
        spotlight.target.position.copy(camera.position).add(cameraDirection); // Move the target
        spotlight.target.updateMatrixWorld();  // Ensure the matrix is updated
        spotlight.position.copy(camera.position);  // Sync position with camera
        spotlight.intensity = 5 + Math.random() * 0.8;
        
    }

    updateCameraPosition();
    checkVendorProximity();
    minimapRenderer.render(scene, minimapCamera);

    // Update any animations
    if (mixers.length > 0) {
        mixers.forEach(mixer => mixer.update(delta));
    }
    if (timerRunning) {
        elapsedTime = Math.floor((Date.now() - startTime) / 1000);

        // Calculate minutes and seconds
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;

        // Display the formatted time
        document.getElementById("time").textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
    }

    renderer.render(scene, camera);
}
        function applyOverlay(){
            if (health <= 30) { // Example threshold for health
                showOverlay();
            } else {
                hideOverlay();
            }
        }
        function showOverlay() {
            healthOverlay.classList.add('pulsate'); // Add pulsating class
            healthOverlay.style.opacity = 1; // Make it visible
        }

        function hideOverlay() {
            healthOverlay.classList.remove('pulsate'); // Remove pulsating class
            healthOverlay.style.opacity = 0; // Fade out
        }

    function applyDamage(amount) {
            if (invincible) {
                console.log("Player is invincible. No damage applied.");
                return;  // Exit the function without applying damage
            }
            health = Math.max(0, health - amount);
            healthElement.textContent = health;
            if (health === 0) {
                endGame('over')
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            minimapRenderer.setSize(200, 200);
        }
        function getSelectedMazeLevel() {
                const level = localStorage.getItem('selectedMazeLevel');
                switch (level) {
                    case 'mazeOne':
                        return mazeOne;
                    case 'mazeTwo':
                        return mazeTwo;
                    case 'mazeThree':
                        return mazeThree;
                    default:
                        return mazeOne; // Default to easy if no selection is made
                }
            }
        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                pauseMenu.style.display = 'block';
                controls.unlock();
            } else {
                pauseMenu.style.display = 'none';
                controls.lock();
            }
        }

        let mazeLevel = getSelectedMazeLevel();
        // Init
        let goalX;
        let goalZ;
        function createPauseMenu() {
            pauseMenu.style.position = 'absolute';
            pauseMenu.style.top = '50%';
            pauseMenu.style.left = '50%';
            pauseMenu.style.transform = 'translate(-50%, -50%)';
            pauseMenu.style.background = 'rgba(0, 0, 0, 0.7)';
            pauseMenu.style.padding = '20px';
            pauseMenu.style.borderRadius = '10px';
            pauseMenu.style.color = 'white';
            pauseMenu.style.textAlign = 'center';
            pauseMenu.style.display = 'none';
            pauseMenu.innerHTML = `
                <h2>Game Paused</h2>
                <button id="resumeButton">Resume</button>
                <button id="quitButton">Quit to Menu</button>
            `;
            document.body.appendChild(pauseMenu);

            document.getElementById('resumeButton').addEventListener('click', togglePause);
            document.getElementById('quitButton').addEventListener('click', () => backToMenu());
        }
        function init(){
            setupScene();
            setupLighting();
            loadCharacterModel();

            if (mazeLevel == mazeOne){
                characterBody.position.set(20,characterHeight/2,3);
                createGround(49,49);
                createVendor(mazeOne);
                createCoins(mazeOne);
                createPhysicsMaze(mazeOne)
                createMaze(mazeOne);
                createTraps(mazeOne);
                createPendulums(mazeOne);
                startTimer();
                goalX = 29;
                goalZ = 49;
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // Directional light
                directionalLight.position.set(10, 30, 10); // Adjust position
                directionalLight.castShadow = true; // Enable shadows

                // Configure the shadow quality for the directional light
                directionalLight.shadow.mapSize.width = 2048; // Shadow map resolution (quality)
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                directionalLight.shadow.camera.near = 1;
                directionalLight.shadow.camera.far = 100;

                scene.add(directionalLight);
            }else if(mazeLevel==mazeTwo){
                characterBody.position.set(28,characterHeight/2,3);
                createGround(65,65);
                createVendor(mazeTwo);
                createCoins(mazeTwo);
                createPhysicsMaze(mazeTwo)
                createMaze(mazeTwo);
                createTraps(mazeTwo);
                createPendulums(mazeTwo);
                startTimer();
                goalX = 37;
                goalZ = 65;
            }else{
                characterBody.position.set(45,characterHeight/2,3);
                createGround(89,89);
                createVendor(mazeThree);
                createCoins(mazeThree);
                createPhysicsMaze(mazeThree)
                createMaze(mazeThree);
                createTraps(mazeThree);
                createPendulums(mazeThree);
                startTimer();
                goalX = 45;
                goalZ = 89;
            }
            addExitLight(goalX,goalZ);
            createPauseMenu();
            setupRiddleEventListeners();

        }
        document.getElementById('backToMenu').addEventListener('click', () => backToMenu());

        // Function to create wall bodies for the maze
        function createPhysicsMaze(mazeArray) {
            // Define the wall shape once (can be reused for each wall)
            const wallThickness = 0.5;  // Increase thickness for better collision detection
            const wallHeight = 3;  // Height of the wall
            const wallMaterial = new CANNON.Material();  // Optional: Assign specific material for the walls

        mazeArray.forEach(wall => {
            // Calculate the length and angle of each wall
            const length = Math.hypot(wall.x2 - wall.x1, wall.y2 - wall.y1);  // Length of the wall
            const angle = Math.atan2(wall.y2 - wall.y1, wall.x2 - wall.x1);  // Angle of the wall in radians

            // Create the wall's shape and body
            const wallShape = new CANNON.Box(new CANNON.Vec3(length / 2, wallHeight / 2, wallThickness / 2));
            const wallBody = new CANNON.Body({
                mass: 0,  // Static wall (mass 0 means it doesn't move)
                shape: wallShape,
                material: wallMaterial,  // Optional: Material for friction, etc.
                position: new CANNON.Vec3(
                    (wall.x1 + wall.x2) / 2,  // Middle point between start and end X positions
                    wallHeight / 2,  // Set the wall's vertical position (Y-axis) based on half its height
                    (wall.y1 + wall.y2) / 2   // Middle point between start and end Z positions (Cannon uses Z instead of Y)
                )
            });

        // Rotate the wall to match its direction in the maze
        wallBody.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -angle);

        // Add the wall body to the Cannon.js physics world
        world.addBody(wallBody);
    });
}


        // Maze
        function createMaze(mazeArray) {
            let wallMaterial;
            if (mazeArray == mazeOne){
                wallMaterial = new THREE.MeshStandardMaterial({ 
                    map: mazeOneWall
                    // map: mazeOneWallBC,
                    // roughnessMap: mazeOneWallR,
                    // normalMap: mazeOneWallN,
                    // aoMap: mazeOneWallAO,
                    // displacementMap: mazeOneWallH,
                    // displacementScale: 0.1
                });
            } else if (mazeArray == mazeTwo){
                wallMaterial = new THREE.MeshStandardMaterial({ map: mazeTwoWall});
            } else {
                wallMaterial = new THREE.MeshStandardMaterial({ map: mazeThreeWall});
            }
            mazeArray.forEach(wall => {
                const length = Math.hypot(wall.x2 - wall.x1, wall.y2 - wall.y1); // Calculate wall length

                // Create wall geometry (e.g., BoxGeometry) based on the length
                const wallGeometry = new THREE.BoxGeometry(length, 6, 0.5); // 3 units tall, 0.5 units thick
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);

                // Position the wall in the middle of its start and end points
                wallMesh.position.set(
                    (wall.x1 + wall.x2) / 2,
                    3,  // Half the height to position on the ground
                    (wall.y1 + wall.y2) / 2
                );

                // Rotate the wall based on its direction
                const angle = Math.atan2(wall.y2 - wall.y1, wall.x2 - wall.x1);
                wallMesh.rotation.y = -angle;

                wallMesh.castShadow = true; // Enable shadow casting
                wallMesh.receiveShadow = true; // Enable shadow receiving
                scene.add(wallMesh); // Add the wall to the scene
            });
        }

        // Vendor-PowerUps and Coins
        function createVendor(mazeNumber) {
            let vendorPositions;

            if (mazeNumber === mazeOne) {
                vendorPositions = [
                    { x: 5, z: 5 },  // Positions for Maze One
                    { x: 35, z: 38 },
                    { x: 2, z: 45 },
                    { x: 26, z: 2 },
                ];
            } else if (mazeNumber === mazeTwo) {
                vendorPositions = [
                    { x: 11, z: 20 }, { x: 27, z: 30 }, { x: 3, z: 63 }, { x: 35, z: 2 }, // Positions for Maze Two
                    { x: 42, z: 50 }
                ];
            } else {
                vendorPositions = [
                    { x: 3, z: 3 },
                    { x: 75, z: 3 },
                    { x: 3, z: 86 },
                    { x: 83, z: 86 },
                    { x: 51, z: 50 },
                    { x: 3, z: 35 },
                    { x: 27, z: 39 }
                ];
            }

            vendors.forEach(vendor => scene.remove(vendor));
            vendors.length = 0;

            vendorPositions.forEach(position => {
                const loader = new GLTFLoader();
                loader.load(
                    'vendor.glb',
                    (gltf) => {
                        const vendor = gltf.scene;
                        vendor.position.set(position.x, 0, position.z);
                        vendor.scale.set(1, 1, 1);
                        scene.add(vendor);
                        vendors.push(vendor);

                        addLightBeam(position);

                        console.log(`Vendor added at x: ${position.x}, z: ${position.z}`);
                    },
                    (xhr) => {
                        console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                    (error) => {
                        console.error('An error happened', error);
                    }
                );
            });
        }

        function addLightBeam(position) {
            const vendorHeight = 2.5;
            const lightStartY = vendorHeight + 0.1;

            const spotlight = new THREE.SpotLight(0xffffff, 1, 0, Math.PI / 4, 1);
            spotlight.position.set(position.x, lightStartY, position.z);
            spotlight.target.position.set(position.x, lightStartY + 100, position.z);
            spotlight.castShadow = true;
            scene.add(spotlight);
            scene.add(spotlight.target);

            const beamHeight = 100;
            const beamGeometry = new THREE.CylinderGeometry(0.5, 0.5, beamHeight, 32, 1, true);
            const beamMaterial = new THREE.MeshBasicMaterial({
                color: 0xb3b3ff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });

            const beam = new THREE.Mesh(beamGeometry, beamMaterial);
            beam.position.set(position.x, lightStartY + beamHeight / 2, position.z);
            scene.add(beam);
            beams.push(beam);
        }


        function createCoins(mazeNumber) {
            let coinPositions;

            if (mazeNumber === mazeOne) {
                coinPositions = [
                    { x: 5, z: 12 }, { x: 12, z: 5 }, { x: 12, z: 45 },
                    { x: 30, z: 30 }, { x: 45, z: 45 }, { x: 20, z: 20 },
                    { x: 45, z: 5 }
                ];
            } else if (mazeNumber === mazeTwo) {
                coinPositions = [
                    { x: 35, z: 30 }, { x: 15, z: 60 }, { x: 20, z: 30 },
                    { x: 4, z: 15 }, { x: 45, z: 13 }, { x: 47, z: 30 },
                    { x: 45, z: 45 }, { x: 60, z: 63 }
                ];
            } else {
                coinPositions = [
                    { x: 12, z: 13 }, { x: 12, z: 50 }, { x: 17, z: 85 },
                    { x: 49, z: 28 }, { x: 49, z: 36 }, { x: 70, z: 50 },
                    { x: 70, z: 60 }
                ];
            }

            coinObjects.forEach(coin => scene.remove(coin));
            coinObjects.length = 0;

            coinPositions.forEach(position => {
                const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);

                const coinMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0xffd700,
                    metalness: 1.0,
                    roughness: 0.2,
                    emissive: 0xffd700,
                    emissiveIntensity: 0.8,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1
                });

                const coin = new THREE.Mesh(coinGeometry, coinMaterial);
                coin.rotation.x = Math.PI / 2;
                coin.position.set(position.x, 0.5, position.z);

                // Add a small point light to simulate the glow
                const glowLight = new THREE.PointLight(0xffd700, 0.5, 3); // Color, intensity, range
                glowLight.position.set(position.x, 0.5, position.z);
                scene.add(glowLight);

                scene.add(coin);
                coinObjects.push(coin);
            });
        }
        function checkForCoins() {
            if (!character) return;

            coinObjects.forEach((coin, index) => {
                const distance = character.position.distanceTo(coin.position);
                if (distance < 1.5) {
                    collectCoin();
                    scene.remove(coin);
                    coinObjects.splice(index, 1);
                }
            });
        }

        function collectCoin() {
            coins = coins + 10;
            console.log(coins);
            coinsElement.textContent = coins;
            console.log(coins);
        }
        function tryInteractWithVendor() {
            if (!character || vendors.length === 0) return;

            vendors.forEach(vendor =>{
                const distance = character.position.distanceTo(vendor.position);
                if (distance <= VENDOR_INTERACTION_DISTANCE) {
                    isInteracting = true;
                    openVendorMenu();
            }
            });
            
        }

        function checkVendorProximity() {
            if (!character || vendors.length === 0) return; // Ensure both character and vendor are loaded
            interactionMessage.style.display = 'none'; // Hide message

            vendors.forEach(vendor =>{
                const distance = character.position.distanceTo(vendor.position);
                if (distance <= VENDOR_INTERACTION_DISTANCE) {
                    interactionMessage.style.display = 'block'; // Show message
                } 
            
            });
            
        }

        
        const timerElement = document.createElement('div');
        timerElement.style.position = 'absolute';
        timerElement.style.top = '10%';
        timerElement.style.left = '50%';
        timerElement.style.transform = 'translate(-50%, -50%)';
        timerElement.style.backgroundColor = 'red';
        timerElement.style.color = 'black';
        timerElement.style.padding = '10px';
        timerElement.style.borderRadius = '5px';
        timerElement.style.fontSize = '18px';
        timerElement.style.fontWeight = 'bold';

        timerElement.style.display = 'none'; // Hide initially
        document.body.appendChild(timerElement);

        function startCountdown(duration, message) {
            let remainingTime = duration;

            timerElement.style.display = 'block';

            const interval = setInterval(() => {
                remainingTime -= 1;
                timerElement.textContent = `${message}: ${remainingTime} seconds`;

                if (remainingTime <= 0) {
                    clearInterval(interval);
                    timerElement.style.display = 'none';
                }
            }, 1000);
        }

        window.buyPowerUp = function (powerUp) {
            if (powerUp === 'superSpeed' && coins >= 10) {
                coins -= 10;
                superSpeedActive = true;
                coinsElement.textContent = coins;

                closePowerUpMenu();
                startCountdown(20, 'Super Speed');

                setTimeout(() => {
                    superSpeedActive = false;
                }, 20000);
            } 
            else if (powerUp === 'healthBoost' && coins >= 15) {
                coins -= 15;
                health = Math.min(100, health + 20);
                healthElement.textContent = health;
                coinsElement.textContent = coins;

                closePowerUpMenu();
            } 
            else if (powerUp === 'Invincibility' && coins >= 10) {
                coins -= 10;
                coinsElement.textContent = coins;
                invincible = true;

                closePowerUpMenu();
                startCountdown(20, 'Invincibility');

                setTimeout(() => {
                    invincible = false;
                }, 20000);
            } 
            else if (powerUp === 'superJump' && coins >= 20) {
                coins -= 20;
                coinsElement.textContent = coins;
                jumpStrength = 30;

                closePowerUpMenu();
                startCountdown(10, 'Super Jump');

                setTimeout(() => {
                    jumpStrength = 6;
                }, 10000);
            } 
            else {
                alert("Not enough coins!");
            }
        };
        function openVendorMenu() {
            vendorMenu.style.display = 'block';
            controls.unlock();
        }

        window.closeVendorMenu = function() {
            vendorMenu.style.display = 'none';
            isInteracting = false;
            controls.lock();
        };

        function setupRiddleEventListeners() {
            document.getElementById('vendorMenu').querySelector('button:nth-child(3)').addEventListener('click', showRiddleMenu);
            document.getElementById('riddleMenu').querySelector('button:nth-child(4)').addEventListener('click', closeRiddleMenu);
        }

        function showRiddleMenu() {
            fetchRiddle();
            riddleMenu.style.display = 'block';
            vendorMenu.style.display = 'none';
        }

        function closeRiddleMenu() {
            riddleMenu.style.display = 'none';
            vendorMenu.style.display = 'block';
        }

        function fetchRiddle() {
            currentRiddle = mockRiddles[Math.floor(Math.random() * mockRiddles.length)];
            document.getElementById('riddleQuestion').textContent = currentRiddle.question;
        }

        function submitRiddleAnswer() {
            const userAnswer = document.getElementById('riddleAnswer').value.toLowerCase().trim();
            if (userAnswer === currentRiddle.answer) {
                coins += 20;
                coinsElement.textContent = coins;
                alert('Correct! You earned 20 coins!');
                closeRiddleMenu();
            } else {
                alert('Sorry, that\'s incorrect. Try again or close the riddle menu.');
            }
        }

        function showPowerUpMenu() {
            powerUpMenu.style.display = 'block';
            vendorMenu.style.display = 'none';
        }   

        function closePowerUpMenu() {
            powerUpMenu.style.display = 'none';
            vendorMenu.style.display = 'block';
        }

        function checkGameStatus(mazeLevel) {
            if(characterBody.position.x<0 || characterBody.position.z<0) {
                endGame('over');
            }
            if ((characterBody.position.x > goalX - 3) && (characterBody.position.x < goalX + 3) &&
                (characterBody.position.z > goalZ - 3) && (characterBody.position.z < goalZ + 3)){
                    stopTimer();
                    endGame('complete');
            }
            console.log(characterBody.position.x);
            console.log(characterBody.position.z);
        }
        function endGame(status) {
        isPaused = true;
        controls.unlock();

        if (status === 'over') {
            document.getElementById('gameOverScreen').style.display = 'block';
        } else if (status === 'complete') {
            document.getElementById('Name').style.display = 'block';
            document.getElementById('submitName').onclick = function() {
            const playerName = document.getElementById('playerName').value.trim();
            if (playerName) {
                addScoreToLeaderboard(playerName, savedTime);
                document.getElementById('Name').style.display = 'none'; 
                } else {
                alert("Please enter a valid name!"); 
                }
            };
            }
    }
    function addScoreToLeaderboard(name, time) {
            const selectedMazeLevel = localStorage.getItem('selectedMazeLevel'); // Retrieve the selected maze level from local storage

            // Determine which leaderboard to update based on the selected maze level
            let leaderboardKey;
            if (selectedMazeLevel === 'mazeOne') {
                leaderboardKey = 'leaderboardMazeOne';
            } else if (selectedMazeLevel === 'mazeTwo') {
                leaderboardKey = 'leaderboardMazeTwo';
            } else if (selectedMazeLevel === 'mazeThree') {
                leaderboardKey = 'leaderboardMazeThree';
            }    

            let leaderboard = JSON.parse(localStorage.getItem(leaderboardKey)) || [];

            leaderboard.push({ name: name, time: time });
            leaderboard.sort((a, b) => a.time - b.time);
            if (leaderboard.length > 10) {
                leaderboard.pop();
            }
            localStorage.setItem(leaderboardKey, JSON.stringify(leaderboard));
            window.location.href = 'index.html';
        }

        function applyGravity() {
            if (!isGrounded) {
        // Apply gravity if the player is not grounded
                character.position.y += jumpVelocity;
                jumpVelocity += gravity;

        // Ensure the character doesn't fall below the ground
                if (character.position.y <= 0) {
                    character.position.y <= 0
                    isGrounded = true;
                    jumpVelocity = 0; // Reset jump velocity when grounded
                }
            }
            character.position.copy(characterBody.position);
        }
        function jump() {
            if (isGrounded) {
                characterBody.velocity.y = jumpStrength;
                jumpVelocity = jumpStrength; // Apply jump strength when jumping
                isGrounded = false; // The player is now in the air
            }
        }

        window.showRiddleMenu = showRiddleMenu;
        window.closeRiddleMenu = closeRiddleMenu;
        window.submitRiddleAnswer = submitRiddleAnswer;
        window.showPowerUpMenu = showPowerUpMenu;
        window.closePowerUpMenu = closePowerUpMenu;

        const minimapCamera = new THREE.OrthographicCamera(
            -50, 50, 50, -50, 1, 1000 // Adjust based on maze size
        );
        minimapCamera.position.set(0, 200, 0);
        if (mazeLevel === mazeOne){
            minimapCamera.lookAt(new THREE.Vector3(49/2, 0, 49/2));  // Look at maze center

        }
        else if(mazeLevel === mazeTwo){
            minimapCamera.lookAt(new THREE.Vector3(65/2, 0, 65/2));  // Look at maze center

        }
        else{
            minimapCamera.lookAt(new THREE.Vector3(89/2, 0, 89/2));  // Look at maze center

        }

    // Create a renderer for the minimap
        const minimapRenderer = new THREE.WebGLRenderer({ antialias: true });
        minimapRenderer.setSize(200, 200);  // Adjust minimap size
        minimapRenderer.domElement.style.position = 'absolute';
        minimapRenderer.domElement.style.top = '10px';
        minimapRenderer.domElement.style.right = '10px';
        document.body.appendChild(minimapRenderer.domElement);
        window.addEventListener('resize', onWindowResize);
        init();
        </script>
            <div id="gameOverScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0,0,0,0.8); color: white; padding: 20px; text-align: center; border-radius: 10px;">
                <h2>Game Over</h2>
                <p>You died. Better luck next time!</p>
                <button onclick="backToMenu()">Back to Main Menu</button>
            </div>
            
            <div id="wellDoneScreen" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0,0,0,0.8); color: white; padding: 20px; text-align: center; border-radius: 10px;">
                <h2>Well Done!</h2>
                <p>You completed the maze!</p>
                <button onclick="backToMenu()">Back to Main Menu</button>
            </div>

    </body>
</html>